<!DOCTYPE html>
<html lang="en">
<head>
    <title>Network Manager & Real-Time Monitor</title>
    <link rel="icon" href="content_objects/site_icon.png" type="image/png"></link>

    <link rel="stylesheet" href="styles/controller.css">
    <link rel="stylesheet" href="styles/client.css">

    <style>

        /* GENERAL CSS */

        html, body, #controller-view, #monitoring-container {
            margin: 0;
            padding: 0;
            height: 100%; /* Ensure the body fits within the viewport */
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #f5f7fa; /* Pleasant light background color */
            overflow: hidden;
        }


        /* PRE-DONE CLASSes */

        .flex-center-all{
            display:flex;
            align-items: center;
            align-content: center;
        }

        .rounded{
            border-radius: 0.25rem;
        }








        /*

            ROLE-CHOOSING
            -> FIRST PAGE + CLIENT CHOOSING PAGE
        */

        .popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding-left: 20px;
            padding-right: 20px;
        }

        .main-popup-content {
            background: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 70%;
        }

        .main-popup-content::-webkit-scrollbar {
            width: 10px;
        }
        .main-popup-content::-webkit-scrollbar-track {
            background: #FFFFFF;
            border-radius: 10px;
        }
        .main-popup-content::-webkit-scrollbar-thumb {
            background: #BCC1C8;
            border-radius: 10px;
            border: 2px solid #FFFFFF;
        }
        .main-popup-content::-webkit-scrollbar-thumb:hover {
            background: #A5ACB5;
        }

        .container-roles {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .role {
            position: relative;
            cursor: pointer;
            text-align: center;
        }

        .role-image {
            max-width: 150px;
            transition: opacity 0.3s ease;
        }

        .role:hover .role-image {
            opacity: 0.4; /* Decrease image opacity on hover */
        }

        .role-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;

            padding: 5px 10px;
            margin: 10px;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
        }

        .role:hover .role-text {
            opacity: 1; /* Show the text on hover */
        }


        /*JUMPING ANIMATION*/

        @keyframes jump {
            0%   {transform: translate3d(0,-5%,0) scale3d(1,1,1);}
            40%  {transform: translate3d(0,30%,0) scale3d(1,1,1);}
            100% {transform: translate3d(0,40%,0) scale3d(1.5,.7,1);}
        }

        .jump {
            transform-origin: 50% 50%;
            animation: jump .6s linear alternate infinite;
        }

        /* CLIENTS CHOOSING */

        .choosing-which-client-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .client-option {
            background: #007bffc9;
            color: white;

            padding: 5px 15px;

            margin: 10px 0;
            border-radius: 5px;
            cursor: pointer;
            width: 80%;
            text-align: center;
            transition: background 0.3s ease;
        }

        .client-option:hover {
            background: #0056b3;
        }























        /*

            EXTRA FOR NOW

        */

        .panel {
            margin: 20px auto;
            padding: 15px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            max-width: 800px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .confirm-button, .back-button {
            margin-top: 20px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .confirm-button {
            background-color: #28a745;
            color: white;
        }
        .back-button {
            background-color: #dc3545;
            color: white;
        }

        /* Receiver Box */
        .receiver-box {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-left: 10px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }





        /* Receiver Item */
        .receiver-item {
            padding: 10px;
            background-color: #f1f1f1;
            color: #333;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            text-align: left;
        }

        .receiver-item:hover {
            background-color: #007bff;
            color: white;
        }

        .server-container {
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .server-header {
            font-size: 18px;
            color: #333;
            margin-bottom: 10px;
            font-weight: bold;
            text-align: left;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }


    </style>
</head>
<body>

<!-- CHOOSING ROLE -->

<div id="role-popup" class="popup">
    <div class="main-popup-content">
        <h1 id="popup-title">Select Your Role</h1>
        <div class="container-roles" id="role-selection">
            <div class="role" onclick="selectRole('controller')">
                <img src="content_objects/controller.png" class="role-image jump">
                <span class="role-text">Controller</span>
            </div>
            <div class="role" onclick="selectRole('client')">
                <img src="content_objects/client.png" class="role-image jump">
                <span class="role-text">Client</span>
            </div>
        </div>
        <div class="choosing-which-client-container" id="client-selection" style="display: none;">
            <div class="client-option" onclick="chooseClient('Client 1')">Client 1</div>
            <div class="client-option" onclick="chooseClient('Client 2')">Client 2</div>
            <div class="client-option" onclick="chooseClient('Client 3')">Client 3</div>
        </div>
    </div>
</div>

<!-- CONTROLLER VIEW -->

<div id="controller-view" style="display: none;">
    <div class="header">
        <div class="previewContainer me-4 ms-4">
            <div class="previewButton">
                <div class="box__face box__face--front rounded" style="background:#00000075"><div class="inside_rotating_button"><div style="text-align:center; width: 100%" class="text-center w-100">
                    Network Manager
                </div></div></div>
                <div class="box__face box__face--back rounded"  style="color:black;background:hsl(186.01deg 100% 50%);"><div class="inside_rotating_button"><div style="text-align:center; width: 100%">
                    Monitoring
                </div></div></div>
            </div>
        </div>
    </div>


    <!-- Clients Display -->
    <div id="network-container">
        <div class="dropdown">
            <button onclick="toggleDropdown()">Menu</button>
            <div class="dropdown-content" id="dropdown-menu">
                <button onclick="orderPanelsByNodeId()">Ordering</button>
                <button onclick="toggleSelectionMode()">Select</button>
                <button class="confirm-button" onclick="confirmSelection()" style="display: none;">Confirm</button>
                <button class="back-button" onclick="goBackToAllNodes()" style="display: none;">Back</button>
            </div>
        </div>
        <svg id="network-canvas"></svg>

        <div id="instructions-container">
            <div class="instruction">
                <img src="content_objects/move-arrows.png" alt="Move the mouse" class="instruction-icon" />
                <span>Move the mouse</span>
            </div>
            <div class="instruction">
                <img src="content_objects/increase_size_icon.png" alt="Use mouse wheel" class="instruction-icon" />
                <span>Use mouse wheel</span>
            </div>
        </div>
    </div>
    <div id="monitoring-container" style="position: relative;">
        <!-- Top Buttons (inside monitoring-container, below header) -->
        <div id="monitoring-tabs">
            <button onclick="showSection('clients-container')" class="tab-button">Clients</button>
            <button onclick="showSection('servers-container')" class="tab-button">Servers</button>
            <button onclick="showSection('drones-container')" class="tab-button">Drones</button>
        </div>

        <!-- Sections -->
        <div id="clients-container" class="section" style="display: block;"></div>
        <div id="servers-container" class="section" style="display: none;"></div>
        <div id="drones-container" class="section" style="display: none;"></div>

        <!-- Filters on the right -->
        <div id="filters">
            <button class="filter-button"></button>
            <button class="filter-button"></button>
            <button class="filter-button"></button>
        </div>
    </div>
</div>

<!-- CLIENT VIEW -->

<div id="client-view" style="display: none;">
    <!-- COMMUNICATION APPLICATION -->
    <div id="communication-ui">
        <div class="header-whatsapp">
            <div class="flex-center-all" style="  user-select: none; ">
                <img src="content_objects/whatsapp_logo.png" alt="whats-logo" class="whatsapp-logo">
                <span class="whatsapp-title">WhatsApp</span>
            </div>
            <img src="content_objects/logout_icon_rev.png" alt="Log Out" class="comm-ui-log_out_button" onclick="logOut()">
        </div>

        <!-- Logout Button -->


        <div class="flex-center-all" style="height:100%">
            <!-- Sidebar for Chats -->
            <div id="chat-sidebar" style="width: 30%; display: flex; flex-direction: column;">
                <div id="sidebar-header">
                    <span>Chats</span>
                    <img src="content_objects/new_chat_icon.png" alt="create_chat" onclick="createNewChat()" style="width:100%; max-width:30px; padding: 5px 10px; cursor: pointer;">
                </div>
                <div id="chat-list">
                    <!-- Example Chat Items with update dot -->
                    <div class="chat-item" data-id="0" onclick="openChat('Chat 1')">
                        <span class="chat-name">Chat 1</span>
                        <span class="update-dot" style="display: none;"></span>
                    </div>
                    <div class="chat-item" data-id="2" onclick="openChat('Chat 2')">
                        <span class="chat-name">Chat 2</span>
                        <span class="update-dot" style="display: none;"></span>
                    </div>
                    <div class="chat-item" data-id="15" onclick="openChat('Chat 3')">
                        <span class="chat-name">Chat 3</span>
                        <span class="update-dot" style="display: none;"></span>
                    </div>
                </div>
            </div>

            <!-- Chat Window -->
            <div id="chat-window">
                <div id="chat-header">
                    Current chat
                </div>
                <div id="chat-messages">
                    <!-- Example Messages -->
                    <div class="message received">Hello!</div>
                    <div class="message sent">Hi there!</div>
                </div>
                <div id="chat-input">
                    <input type="text" id="message-input" placeholder="Type a message...">
                    <button onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>




    <!-- CONTENT APPLICATION -->
    <div id="content-ui">
        <!-- Header -->
        <div id="header-content-ui">
            <img src="content_objects/chrome_logo.png" alt="Google Drive" class="drive-logo">

            <div class="search-bar">
                <img src="content_objects/search_icon.png" alt="Search Icon" class="search-icon" onclick="searchGoogleDrive()">
                <input type="text" class="search-input" placeholder="Search" onkeypress="handleSearchKeyPress(event)">
                <div class="filter-container">
                    <img src="content_objects/filter_icon_png.png" alt="Filter Icon" class="filter-icon">
                    <div class="filter-dropdown">
                        <button class="filter-option" data-type="png">PNG</button>
                        <button class="filter-option" data-type="jpg">JPG</button>
                        <button class="filter-option" data-type="html">HTML</button>
                        <button class="filter-option" data-type="mp3">MP3</button>
                        <button class="filter-option" data-type="">All</button>
                    </div>
                </div>
            </div>

            <!-- Logout Button -->
            <img src="content_objects/logout_icon.png" alt="Log Out" class="content-ui-log_out_button" onclick="logOut()">
        </div>

        <!-- Body -->
        <div id="body-content-ui">
            <div id="side-bar-content-ui" style="display:none"></div>

            <div id="content-container-content-ui">
                <!-- SERVER SELECTOR -->
                <div id="server-selector">
                    <div style="display:flex">
                        <span id="current-server"></span>

                        <div class="server-nav">
                            <img src="content_objects/up_arrow.png" alt="Up" class="server-arrow" onclick="navigateServer(-1)">
                            <img src="content_objects/down_arrow.png" alt="Down" class="server-arrow" onclick="navigateServer(1)">
                        </div>
                    </div>

                    <img src="content_objects/reload.png" alt="reload" class="reload-button" onclick="reloadFilesServer(get_server_id_from_current_server_index())">
                </div>




                <!-- File List -->
                <table class="file-list">
                </table>

                <!-- Loading Pop-up Overlay for Reload -->
                <div id="loading-popup" class="file-loading-overlay" style="display: none;">
                    <div class="file-loading-content">
                        <img src="content_objects/reload.png" alt="Loading..." class="file-loading-gif">
                        <p style="margin-top:0">Retrieving files... Take a coffee meanwhile (b^_^)</p>
                    </div>
                </div>


            </div>


        </div>


        <!-- Pop-up file -->
        <div id="file-popup" class="file-popup-overlay" onclick="closePopup()">
            <div class="file-popup-content" onclick="event.stopPropagation();">
                <!-- Close Button -->
                <button class="file-close-button" onclick="closePopup()">X</button>

                <!-- File Title -->
                <h2 id="file-popup-title"></h2>

                <!-- File Content -->
                <div id="file-popup-file-content"></div>
            </div>
        </div>
    </div>
</div>

<!-- Pop Ups for CLIENT VIEW -->

<div id="chat-popup" class="popup-container">
    <div class="popup-content">
        <h2>Select a Receiver</h2>
        <div id="receiver-list" class="receiver-list">
            <!-- List boxes for servers will be dynamically created -->
        </div>
        <div class="popup-actions">
            <button onclick="confirmSelection()" class="popup-button choose-button">Choose</button>
            <button onclick="closeChatPopup()" class="popup-button close-button">Close</button>
        </div>
    </div>
</div>











<script>


    // Create a WebSocket connection to the Rust server
    const wsHost = window.location.hostname || 'localhost';
    const ws = new WebSocket(`ws://${wsHost}:8080`);

    // Nodes-tracker
    let data = {};

    // Role-tracker
    const roles_vector = [
        "undefined",
        "controller",
        "chat_client",
        "web_client"
    ];
    let current_role_chosen = roles_vector[0];
    let currentClientId = null; // Global variable

    // Container for all panels
    const monitoringContainer = document.getElementById("monitoring-container");
    const requestedMedia = new Set(); // Track requested media references




    /*

        CHOOSE ROLE

    */

    function changeIconSite(newIconUrl) {
        let favicon = document.querySelector("link[rel*='icon']");
        if (!favicon) {
            // If no favicon exists, create one.
            favicon = document.createElement("link");
            favicon.rel = "icon";
            document.head.appendChild(favicon);
        }
        favicon.href = newIconUrl;
    }

    function selectRole(role) {
        const popupTitle = document.getElementById('popup-title');
        const roleSelection = document.getElementById('role-selection');
        const clientSelection = document.getElementById('client-selection');
        const clientsDisplayDiv = document.getElementById('clients-container');

        if (role === 'controller') {
            //Set role and icon
            current_role_chosen = roles_vector[1];
            changeIconSite("content_objects/controller_icon.png")

            // Hide the pop-up and show the controller view
            document.getElementById('role-popup').style.display = 'none';
            document.getElementById('controller-view').style.display = 'block';

        } else if (role === 'client') {
            // Update the pop-up for client selection
            popupTitle.textContent = 'Select a Client';
            document.querySelector('.main-popup-content').style.overflowY = 'scroll';
            roleSelection.style.display = 'none';
            clientSelection.style.display = 'flex';

            // Dynamically create client options
            const panelsArray = Array.from(clientsDisplayDiv.querySelectorAll('.panel'));
            clientSelection.innerHTML = ''; // Clear existing options

            if (panelsArray.length === 0) {
                // No nodes found, show error message
                const errorMessage = document.createElement('div');
                errorMessage.textContent = 'No clients available.';
                errorMessage.style.color = 'red';
                errorMessage.style.textAlign = 'center';
                clientSelection.appendChild(errorMessage);
            } else {

                // Create buttons for each panel (node)
                panelsArray.forEach((panel) => {

                    const nodeId = panel.dataset.nodeId || 'Unknown'; // Retrieve node_id from panel's dataset
                    const nodeType = panel.dataset.nodeType || 'Unknown'; // Retrieve node_type from panel's dataset


                    // Create the button-option
                    const clientButton = document.createElement('div');
                    clientButton.style = "display:flex; align-items: center; justify-content: start";
                    clientButton.className = "client-option";
                    clientButton.onclick = () => chooseClient(nodeId);

                    // Create the image associated with client Type
                    const img = document.createElement('img');
                    img.style.width = "100%";
                    img.style.maxWidth = "30px";
                    img.style.borderRadius = "7px";

                    if (nodeType === "Chat Client") {
                        img.src = "content_objects/whatsapp.jpg"; // Default image
                        img.alt = "whatsapp";
                    } else {
                        img.src = "content_objects/google_drive.png"; // Use Google Drive image for Web Browser
                        img.alt = "google_drive";
                    }

                    // Create text next to the image
                    const text = document.createElement('p');
                    text.textContent = `Client nodeId: ${nodeId}`;
                    text.style = "margin-left: 10px";

                    clientButton.appendChild(img);
                    clientButton.appendChild(text);

                    clientSelection.appendChild(clientButton);
                });
            }
        }
    }

    function chooseClient(nodeId) {
        currentClientId = nodeId;
        console.log(`Client chosen: Node ${nodeId}`);

        // Find the panel corresponding to the selected nodeId
        const panel = document.querySelector(`.panel[data-node-id="${nodeId}"]`);

        if (!panel) {
            console.error(`No panel found for Node ${nodeId}`);
            return;
        }

        // retrieving nodeType
        const nodeType = panel.dataset.nodeType;
        console.log(`Type chosen ${nodeType}`)

        // Show the appropriate UI based on the nodeType
        const communicationUI = document.getElementById('communication-ui');
        const contentUI = document.getElementById('content-ui');
        if (nodeType === 'Chat Client') {
            //Set role & change Icon
            current_role_chosen = roles_vector[2];
            changeIconSite("content_objects/whatsapp_logo.png")


            // Add placeholder image and text in chat messages
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <img src="content_objects/whatsapp_light_icon.png" alt="WhatsApp Icon" style="max-width: 150px; opacity: 0.7;">
                    <p style="color: #555; margin-top: 10px; font-size: 16px; color: #54656f">Here there will be shown your personal chats!</p>
                </div>
            `;

            chatMessages.style.background = 'none'; // Clear background for placeholder
            chatMessages.style.backgroundColor = '#111B21'


            communicationUI.style.display = 'flex';
            contentUI.style.display = 'none';

            populateChatListForClient();
            populateChatReceiversForClient();
        } else {
            //Set role & change Icon
            current_role_chosen = roles_vector[3];
            changeIconSite("content_objects/chrome_logo.png")

            communicationUI.style.display = 'none';
            contentUI.style.display = 'flex';

            populateContentServersForClient()
        }

        // Transition to the client view
        document.getElementById('role-popup').style.display = 'none';
        document.getElementById('client-view').style.display = 'block';

    }

    function populateChatListForClient() {
        // Find the panel in the clients-container for this clientId.
        const panel = document.querySelector(`.panel[data-node-id="${currentClientId}"]`);
        if (!panel) {
            console.error("No panel found for client", currentClientId);
            return;
        }

        // Parse the stored history, if available.
        let history = {};
        if (panel.dataset.history) {
            try {
                history = JSON.parse(panel.dataset.history);
            } catch (e) {
                console.error("Error parsing chat history:", e);
            }
        }

        console.log(history)

        // Clear the existing chat list.
        const chatList = document.getElementById('chat-list');
        chatList.innerHTML = "";

        // For each chat partner in the history, create a chat item.
        for (let partnerId in history) {
            const chatItem = document.createElement('div');
            chatItem.className = 'chat-item';
            chatItem.dataset.id = partnerId;
            chatItem.dataset.history = JSON.stringify(history[partnerId]);

            // Use the partnerId as the chat name (or look it up if you have a mapping).
            chatItem.innerHTML = `<span class="chat-name">${partnerId}</span><span class="update-dot" style="display: none;"></span>`;

            // When the chat is clicked, open it.
            chatItem.onclick = function() {
                openChat(partnerId, partnerId);
            };

            chatList.appendChild(chatItem);
        }
    }

    function populateChatReceiversForClient() {
        // Find the panel for the current client.
        const panel = document.querySelector(`.panel[data-node-id="${currentClientId}"]`);
        if (!panel) {
            console.error("No panel found for client", currentClientId);
            return;
        }

        // Try to parse the available_clients field; if it doesn't exist, use an empty array.
        let availableClients = [];
        if (panel.dataset.hash_list_receivers) {
            try {
                availableClients = JSON.parse(panel.dataset.hash_list_receivers);
            } catch (e) {
                console.error("Error parsing hash_list_receivers:", e);
            }
        }

        //populate phonebooks
        for (const serverId in availableClients){
            phonebooks[serverId] = availableClients[serverId];
        }

        // Get the container where the receivers will be listed.
        const receiverListContainer = document.getElementById('receiver-list');

        // If there are no available clients, display a message.
        if (!availableClients || availableClients.length === 0) {
            receiverListContainer.innerHTML = `<div style="text-align: center; color: red;">No available clients</div>`;
        }
    }

    function populateContentServersForClient(){
        // Find the panel for the current client.
        const panel = document.querySelector(`.panel[data-node-id="${currentClientId}"]`);
        if (!panel) {
            console.error("No panel found for client", currentClientId);
            return;
        }

        // Try to parse the available_clients field; if it doesn't exist, use an empty array.
        let available_servers = [];
        if (panel.dataset.content_servers) {
            try {
                available_servers = JSON.parse(panel.dataset.content_servers);
                console.log(available_servers)
            } catch (e) {
                console.error("Error parsing available_servers:", e);
            }
        }

        for (const serverId of available_servers) {
            file_lists[serverId] = {
                "name" : `Server Id: ${serverId}`,
                "files" : {},
            }
        }

        // Update the current-server display.
        if (available_servers.length > 0) {
            document.getElementById("current-server").innerHTML = `Server Id: ${available_servers[0]}`;
        } else {
            document.getElementById("current-server").innerHTML = "No server available";
        }

        console.log(available_servers)
        // Hide or show the server navigation arrows based on the number of available servers.
        const serverNav = document.querySelector('.server-nav');
        if (serverNav) {
            if (available_servers.length <= 1) {
                serverNav.style.display = "none";
            } else {
                serverNav.style.display = "flex";
            }
        }
    }

    function logOut() {
        // Redirect to the login or home screen
        console.log('Logging out...');

        // Optional: Redirect to the login page
        window.location.reload(); // Reload the page to reset state
    }



















    /*

           WEB SOCKET FUNCTIONS

     */


    ws.onmessage = async (event) => {
        try {
            // Log only critical information
            console.time("PacketProcessing");

            const text = event.data; // Removed unnecessary `await`
            const parsedData = JSON.parse(text);
            console.log(parsedData)
            switch (current_role_chosen) {
                case "undefined":
                    // Handle only data with "data_title" field
                    if (parsedData.hasOwnProperty("data_title")) {
                        console.log("Processing full dataset for undefined role...");
                        createMonitoringSections(parsedData);
                        createTopology(parsedData.topology);
                    } else {
                        console.log("Discarded data without 'data_title' for undefined role.");
                    }
                    break;

                case "controller":
                    console.log(parsedData);
                    // Handle updates for individual nodes
                    if (parsedData.hasOwnProperty("node_type")) {
                        if (parsedData.node_type === "Web Browser" || parsedData.node_type === "Chat Client"){

                        }else if (parsedData.node_type === "Drone"){

                        }else{

                        }
                        console.log("Processing node update for controller...");
                        switch (parsedData.node_type) {
                            case "Web Browser":
                                console.log("Updating Web Browser section...");
                                // Add logic to update the Web Browser section
                                break;
                            case "Chat Client":
                                console.log("Updating Chat Client section...");
                                // Add logic to update the Chat Client section
                                break;
                            case "Communication Server":
                                console.log("Updating Communication Server section...");
                                // Add logic to update the Communication Server section
                                break;
                            case "Media Server":
                                console.log("Updating Media Server section...");
                                // Add logic to update the Media Server section
                                break;
                            case "Text Server":
                                console.log("Updating Text Server section...");
                                // Add logic to update the Text Server section
                                break;
                            default:
                                console.warn(`Unknown node type: ${parsedData.node_type}`);
                                break;
                        }
                    } else {
                        console.warn("Discarded data without 'node_type' for controller role.");
                    }
                    break;

                case "chat_client":

                    if (parsedData.hasOwnProperty("chats")){
                        console.log(parsedData.available_clients)
                        if (parsedData.node_id == currentClientId){
                            updateChats(parsedData.node_id, parsedData.chats);
                            updateChatReceivers(parsedData.available_clients);
                        }
                    }else{
                        console.warn("Discarded not chat Client.");
                    }

                    break;

                case "web_client":
                    if (parsedData.node_id == currentClientId){
                        console.log("arrivedData_web_client")
                        updateFileList(parsedData.curr_received_file_list);
                        updateFile(parsedData.chosen_file_text);
                        updateMedia(parsedData.serialized_media)
                    }
                    break;

                default:
                    console.warn(`Unhandled role: ${current_role_chosen}`);
            }
            console.timeEnd("PacketProcessing");
        } catch (error) {
            console.error("Error processing WebSocket message:", error);
        }
    };

    // Handle WebSocket connection close
    ws.onclose = () => {
        const msgDiv = document.createElement("div");
        msgDiv.className = "message error";
        msgDiv.textContent = 'WebSocket connection closed.';
    };

    // Handle WebSocket connection open
    ws.onopen = () => {
        console.log('WebSocket connection established');
        sendUpdateCommand(); // Request initial data on connection
    };
    // Handle page refresh/visibility changes
    window.addEventListener('beforeunload', () => {
        console.log("ciao4");
        sendUpdateCommand(); // Optional: Send cleanup command if needed
    });

    // Request update when the page becomes visible again
    document.addEventListener('visibilitychange', () => {
        console.log("ciao5");
        if (document.visibilityState === 'visible') {
            sendUpdateCommand();
        }
    });

    // Handle WebSocket errors
    ws.onerror = (error) => {
        console.error('WebSocket error:', error);
    };


    function sendUpdateCommand() {
        if (ws.readyState === WebSocket.OPEN) {
            const message = { "WsUpdateData": null }; // Use null or an empty object
            ws.send(JSON.stringify(message));
            console.log("Sent:", JSON.stringify(message)); // Debugging output
        } else {
            console.error("WebSocket is not open. Unable to send request.");
        }
    }


























    /*

       WEB SOCKET FUNCTIONS
       -> UPDATING FIELDS

     */

    function createTopology(topologyData) {
        // Clear any previous data
        drawn_nodes.length = 0;
        connections.length = 0;

        // Get all unique node IDs from the topology object.
        const nodeIds = Object.keys(topologyData);
        const totalNodes = nodeIds.length;

        // Set up parameters for a circle layout.
        const centerX = 1000; // adjust as needed
        const centerY = 1000; // adjust as needed
        const radius = 400;   // distance from center

        // Position each node on a circle.
        nodeIds.forEach((nodeId, i) => {
            const angle = (2 * Math.PI * i) / totalNodes;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            // For simplicity, set type to "node" (or you can decide based on nodeId)
            drawn_nodes.push({ id: nodeId, type: "node", x: x, y: y });
        });

        // Build connections from topologyData.
        for (const [nodeId, targetNodes] of Object.entries(topologyData)) {
            targetNodes.forEach(targetId => {
                connections.push({ from: nodeId, to: targetId });
            });
        }

        // Now update the SVG canvas.
        const canvas = document.getElementById("network-canvas");
        // Clear any existing children.
        while (canvas.firstChild) {
            canvas.removeChild(canvas.firstChild);
        }

        // Draw connections (lines).
        connections.forEach(conn => {
            const fromNode = drawn_nodes.find(n => n.id == conn.from);
            const toNode = drawn_nodes.find(n => n.id == conn.to);
            if (fromNode && toNode) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", fromNode.x);
                line.setAttribute("y1", fromNode.y);
                line.setAttribute("x2", toNode.x);
                line.setAttribute("y2", toNode.y);
                line.classList.add("connection");
                canvas.appendChild(line);
            }
        });

        // Draw nodes (circles).
        drawn_nodes.forEach(node => {
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", node.x);
            circle.setAttribute("cy", node.y);
            circle.setAttribute("r", 15);
            console.log(node.type)
            circle.classList.add("node", node.type);
            circle.addEventListener("click", () => alert(`Node: ${node.id}`));
            canvas.appendChild(circle);
        });
    }

    function createMonitoringSections(data) {
        // Sections for monitoring
        const clientsContainer = document.getElementById("clients-container");
        const serversContainer = document.getElementById("servers-container");
        const dronesContainer = document.getElementById("drones-container");

        // Clear existing panels
        clientsContainer.innerHTML = '';
        serversContainer.innerHTML = '';
        dronesContainer.innerHTML = '';

        // Helper function to create a panel for a node
        function createPanel(nodeId, nodeType, fields) {
            const panel = document.createElement("div");
            panel.className = "panel";
            panel.dataset.nodeId = nodeId;
            panel.dataset.nodeType = nodeType;

            // Title with node_id and node_type
            const title = document.createElement("h3");
            title.textContent = `Node ID: ${nodeId} | Type: ${nodeType}`;
            panel.appendChild(title);

            // Display all fields
            const fieldsContainer = document.createElement("div");
            Object.entries(fields).forEach(([key, value]) => {
                const field = document.createElement("p");
                field.style= "overflow-wrap: break-word";
                field.textContent = `${key}: ${JSON.stringify(value)}`;
                fieldsContainer.appendChild(field);
            });
            panel.appendChild(fieldsContainer);

            return panel;
        }

        // Add panels for web_clients_data
        Object.entries(data.web_clients_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Web Client", fields);
            panel.dataset.content_servers = JSON.stringify(fields.discovered_text_servers);
            clientsContainer.appendChild(panel);
        });

        // Add panels for chat_clients_data
        Object.entries(data.chat_clients_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Chat Client", fields);
            panel.dataset.history = JSON.stringify(fields.chats);
            console.log(panel.dataset.history)
            panel.dataset.hash_list_receivers = JSON.stringify(fields.available_clients)
            clientsContainer.appendChild(panel);
        });

        // Add panels for comm_servers_data
        Object.entries(data.comm_servers_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Communication Server", fields);
            serversContainer.appendChild(panel);
        });

        // Add panels for text_servers_data
        Object.entries(data.text_servers_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Text Server", fields);
            serversContainer.appendChild(panel);
        });

        // Add panels for media_servers_data
        Object.entries(data.media_servers_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Media Server", fields);
            serversContainer.appendChild(panel);
        });

        Object.entries(data.drones_data).forEach(([nodeId, fields]) => {
            const panel = createPanel(nodeId, "Drone", fields);
            dronesContainer.appendChild(panel);
        });

        const panel_padding = document.createElement('p');
        panel_padding.style = "height:10px; width:100%; padding-bottom: 300px;"

        clientsContainer.appendChild(panel_padding.cloneNode(true));
        serversContainer.appendChild(panel_padding.cloneNode(true));
        dronesContainer.appendChild(panel_padding.cloneNode(true));


        console.log("Monitoring sections updated!");
    }
    function updateNode(){

    }























    /*

      EXTRA FOR NOW

    */



    // Function to order panels by node_id
    function orderPanelsByNodeId() {
        const panelsArray = Object.values(panels);
        panelsArray.sort((a, b) => {
            const nodeIdA = parseInt(a.dataset.nodeId, 10);
            const nodeIdB = parseInt(b.dataset.nodeId, 10);
            return nodeIdA - nodeIdB;
        });

        // Clear the container and re-append panels in sorted order
        panelsContainer.innerHTML = '';
        panelsArray.forEach(panel => panelsContainer.appendChild(panel));
    }

    // Function to toggle selection mode
    function toggleSelectionMode() {
        isSelectionMode = !isSelectionMode;
        document.querySelector('.confirm-button').style.display = isSelectionMode ? 'block' : 'none';
        document.querySelector('.back-button').style.display = 'none'; // Hide back button in selection mode
        updateSelectionSquaresVisibility();
    }

    // Function to update the visibility of selection squares
    function updateSelectionSquaresVisibility() {
        Object.values(panels).forEach(panel => {
            const square = panel.querySelector('.selection-square');
            if (square) {
                square.style.display = isSelectionMode ? 'block' : 'none';
            }
        });
    }

    // Function to confirm the selection
    function confirmSelection() {
        isSelectionMode = false;
        document.querySelector('.confirm-button').style.display = 'none';
        document.querySelector('.back-button').style.display = 'block'; // Show back button after confirmation
        updateSelectionSquaresVisibility();
        filterPanelsBySelectedNodes();
    }

    // Function to filter panels based on selected nodes
    function filterPanelsBySelectedNodes() {
        Object.values(panels).forEach(panel => {
            const nodeId = panel.dataset.nodeId;
            if (selectedNodes.has(nodeId)) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        });
    }

    // Function to go back to monitoring all nodes
    function goBackToAllNodes() {
        selectedNodes.clear(); // Clear selected nodes
        document.querySelector('.back-button').style.display = 'none'; // Hide back button
        document.querySelector('.confirm-button').style.display = 'none'; // Hide confirm button
        Object.values(panels).forEach(panel => {
            panel.style.display = 'block'; // Show all panels
            const square = panel.querySelector('.selection-square');
            if (square) {
                square.classList.remove('selected'); // Remove selection tick
            }
        });
    }

    // Function to toggle node selection
    function toggleNodeSelection(nodeId) {
        if (selectedNodes.has(nodeId)) {
            selectedNodes.delete(nodeId);
        } else {
            selectedNodes.add(nodeId);
        }
        const square = document.querySelector(`.panel[data-node-id="${nodeId}"] .selection-square`);
        square.classList.toggle('selected');
    }






</script>
<script src="js/client.js"></script>
<script src="js/controller.js"></script>
</body>
</html>
